<!-- @format -->

## 클라이언트가 클래스의 인스턴스를 얻는 수단

1. 전통적인 수단 : `public` 생성자
2. 클래스의 인스턴스를 반환하는 `정적 메소드`

- 2번이 정적 팩토리 메소드에 해당

## 정적 팩토리 메소드 예시

```java
public statuc Boolean valueOf(boolean b){
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

## 정적 팩토리 메소드 사용 장점

1. 이름을 가질 수 있다

- 반환될 객체의 이름을 직접 지어줄 수 있다.
- 하나의 시그니처 (위의 함수에서 `valueOf(boolean b)` 부분)로는 생성자를 하나만 만들 수 있는데, 정적 팩토리 메소드는 이름을 바꿔서 한 코드로 여러 인스턴스를 생성할 수 있다.

2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다

- 반복되는 요청에 같은 객체를 반환하므로 `인스턴스 통제 클래스`를 만들 수 있다.
- 인스턴스 통제를 통해 클래스를 `singleton` 클래스로 만들 수 있고 인스턴스화 불가로 만들 수도 있다.
- 반드시 인스턴스가 하나여야 하는 경우(`a.equals(b)`같은 코드)에 인스턴스가 하나만 만들어짐을 보장한다.
- 같은 객체가 자주 요청되는 상황에서 성능을 끌어올려줄 수 있다.

3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다

- 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 엄청난 유연성! ✨
- 인터페이스에 정적 팩토리 메소드 (이거 무조건 `public`) 를 선언하면 구현체 코드를 공개하지 않아도 구현체의 객체를 반환할 수 있다.
- 정적 팩토리 메소드를 사용하는 클라이언트는 얻은 객체를 인터페이스만으로 다룰 수 있으며 API도 작게 유지할 수 있다.

4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

- 반환 타입의 하위 타입에 한정된 기능!, 즉 하위 클래스의 객체를 매개변수를 조정해가며 마음껏 반환할 수 있다.
- 이런 특징 때문에 클라이언트는 팩토리가 건네주는 객체가 어던 클래스의 인스턴스인지 알 수 없다.

5. 정적 팩토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다 = 서비스 제공자 프레임워크를 만들 수 있다

- 서비스 제공자 프레임워크의 핵심 컴포넌트 = (서비스 인터페이스, 제공자 등록 API, 서비스 접근 API)
- 서비스 접근 API : 클라이언트가 서비스 API에 접근할 때 원하는 구현체의 조건을 명시한다. 이게 유연한 정적 팩토리의 실체!
- 따라서 공급자가 제공하는 것보다 더 풍부한 서비스 인터페이스를 클라이언트에 반환할 수 있다. - 브릿지 패턴, 의존 객체 주입

## 정적 팩토리 메소드 사용 단점

1. 상속을 하려면 `public`이나 `protected` 생성자가 필요하기 때문에 정적 팩토리 메소드만 제공하면 하위 클래스를 만들 수 없다

- 정적 팩토리 메소드만 있는 클래스를 만들면 `public` 이나 `protected` 로 선언된 생성자 없고, 이럴 경우 상속이 불가능하다.

2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다

- 외관상으로 봤을 때 다른 메소드들과 구분되는 점이 없어 찾기가 일단 어렵다.
- 생성자는 API설명에 명확히 드러나는데 정적 팩토리 메소드는 사용자가 정적 팩토리 메소드 방식 클래스를 인스턴스화할 방법을 알아서 알아내야 한다.
- 따라서 메소드 이름을 널리 알려진 규약을 따라 짓는 식으로 이 문제를 환화해야 한다.

## 핵심 요약

> 정적 팩토리를 사용하는게 public 생성자를 사용하는 것보다 유리한 경우가 더 많다. 따라서 쓰임새를 보고 잘 판단해서 사용해야 한다.
